/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: api/workloadapi/security/authorization.proto */

#ifndef PROTOBUF_C_api_2fworkloadapi_2fsecurity_2fauthorization_2eproto__INCLUDED
#define PROTOBUF_C_api_2fworkloadapi_2fsecurity_2fauthorization_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003003 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _Security__Authorization Security__Authorization;
typedef struct _Security__Rule Security__Rule;
typedef struct _Security__Clause Security__Clause;
typedef struct _Security__Match Security__Match;
typedef struct _Security__Address Security__Address;
typedef struct _Security__StringMatch Security__StringMatch;


/* --- enums --- */

typedef enum _Security__Scope {
  /*
   * ALL means that the authorization policy will be applied to all workloads
   * in the mesh (any namespace).
   */
  SECURITY__SCOPE__GLOBAL = 0,
  /*
   * NAMESPACE means that the policy will only be applied to workloads in a
   * specific namespace.
   */
  SECURITY__SCOPE__NAMESPACE = 1,
  /*
   * WORKLOAD_SELECTOR means that the policy will only be applied to specific
   * workloads that were selected by their labels.
   */
  SECURITY__SCOPE__WORKLOAD_SELECTOR = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SECURITY__SCOPE)
} Security__Scope;
typedef enum _Security__Action {
  /*
   * Allow the request if it matches with the rules.
   */
  SECURITY__ACTION__ALLOW = 0,
  /*
   * Deny the request if it matches with the rules.
   */
  SECURITY__ACTION__DENY = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SECURITY__ACTION)
} Security__Action;

/* --- messages --- */

struct  _Security__Authorization
{
  ProtobufCMessage base;
  char *name;
  char *namespace_;
  /*
   * Determine the scope of this RBAC policy.
   * If set to NAMESPACE, the 'namespace' field value will be used.
   */
  Security__Scope scope;
  /*
   * The action to take if the request is matched with the rules.
   * Default is ALLOW if not specified.
   */
  Security__Action action;
  /*
   * Set of RBAC policy rules each containing its cluases (To, From, When).
   * If at least one of the rules is matched the policy action will
   * take place.
   * Rules are OR-ed.
   */
  size_t n_rules;
  Security__Rule **rules;
};
#define SECURITY__AUTHORIZATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&security__authorization__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, SECURITY__SCOPE__GLOBAL, SECURITY__ACTION__ALLOW, 0,NULL }


struct  _Security__Rule
{
  ProtobufCMessage base;
  /*
   * Clauses are AND-ed
   * This is a generic form of the authz policy's to, from and when
   */
  size_t n_clauses;
  Security__Clause **clauses;
};
#define SECURITY__RULE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&security__rule__descriptor) \
    , 0,NULL }


struct  _Security__Clause
{
  ProtobufCMessage base;
  /*
   * The logical behavior between the matches (if there are more than one)
   *  MatchBehavior match_behavior = 1;
   * Matches are OR-ed
   * Match is a generic form of the authz policy's expressions contained in To, From and When.
   */
  size_t n_matches;
  Security__Match **matches;
};
#define SECURITY__CLAUSE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&security__clause__descriptor) \
    , 0,NULL }


struct  _Security__Match
{
  ProtobufCMessage base;
  size_t n_namespaces;
  Security__StringMatch **namespaces;
  size_t n_not_namespaces;
  Security__StringMatch **not_namespaces;
  size_t n_principals;
  Security__StringMatch **principals;
  size_t n_not_principals;
  Security__StringMatch **not_principals;
  size_t n_source_ips;
  Security__Address **source_ips;
  size_t n_not_source_ips;
  Security__Address **not_source_ips;
  size_t n_destination_ips;
  Security__Address **destination_ips;
  size_t n_not_destination_ips;
  Security__Address **not_destination_ips;
  size_t n_destination_ports;
  uint32_t *destination_ports;
  size_t n_not_destination_ports;
  uint32_t *not_destination_ports;
};
#define SECURITY__MATCH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&security__match__descriptor) \
    , 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL }


struct  _Security__Address
{
  ProtobufCMessage base;
  ProtobufCBinaryData address;
  uint32_t length;
};
#define SECURITY__ADDRESS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&security__address__descriptor) \
    , {0,NULL}, 0 }


typedef enum {
  SECURITY__STRING_MATCH__MATCH_TYPE__NOT_SET = 0,
  SECURITY__STRING_MATCH__MATCH_TYPE_EXACT = 1,
  SECURITY__STRING_MATCH__MATCH_TYPE_PREFIX = 2,
  SECURITY__STRING_MATCH__MATCH_TYPE_SUFFIX = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SECURITY__STRING_MATCH__MATCH_TYPE)
} Security__StringMatch__MatchTypeCase;

struct  _Security__StringMatch
{
  ProtobufCMessage base;
  Security__StringMatch__MatchTypeCase match_type_case;
  union {
    /*
     * exact string match
     */
    char *exact;
    /*
     * prefix-based match
     */
    char *prefix;
    /*
     * suffix-based match
     */
    char *suffix;
  };
};
#define SECURITY__STRING_MATCH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&security__string_match__descriptor) \
    , SECURITY__STRING_MATCH__MATCH_TYPE__NOT_SET, {0} }


/* Security__Authorization methods */
void   security__authorization__init
                     (Security__Authorization         *message);
size_t security__authorization__get_packed_size
                     (const Security__Authorization   *message);
size_t security__authorization__pack
                     (const Security__Authorization   *message,
                      uint8_t             *out);
size_t security__authorization__pack_to_buffer
                     (const Security__Authorization   *message,
                      ProtobufCBuffer     *buffer);
Security__Authorization *
       security__authorization__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   security__authorization__free_unpacked
                     (Security__Authorization *message,
                      ProtobufCAllocator *allocator);
/* Security__Rule methods */
void   security__rule__init
                     (Security__Rule         *message);
size_t security__rule__get_packed_size
                     (const Security__Rule   *message);
size_t security__rule__pack
                     (const Security__Rule   *message,
                      uint8_t             *out);
size_t security__rule__pack_to_buffer
                     (const Security__Rule   *message,
                      ProtobufCBuffer     *buffer);
Security__Rule *
       security__rule__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   security__rule__free_unpacked
                     (Security__Rule *message,
                      ProtobufCAllocator *allocator);
/* Security__Clause methods */
void   security__clause__init
                     (Security__Clause         *message);
size_t security__clause__get_packed_size
                     (const Security__Clause   *message);
size_t security__clause__pack
                     (const Security__Clause   *message,
                      uint8_t             *out);
size_t security__clause__pack_to_buffer
                     (const Security__Clause   *message,
                      ProtobufCBuffer     *buffer);
Security__Clause *
       security__clause__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   security__clause__free_unpacked
                     (Security__Clause *message,
                      ProtobufCAllocator *allocator);
/* Security__Match methods */
void   security__match__init
                     (Security__Match         *message);
size_t security__match__get_packed_size
                     (const Security__Match   *message);
size_t security__match__pack
                     (const Security__Match   *message,
                      uint8_t             *out);
size_t security__match__pack_to_buffer
                     (const Security__Match   *message,
                      ProtobufCBuffer     *buffer);
Security__Match *
       security__match__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   security__match__free_unpacked
                     (Security__Match *message,
                      ProtobufCAllocator *allocator);
/* Security__Address methods */
void   security__address__init
                     (Security__Address         *message);
size_t security__address__get_packed_size
                     (const Security__Address   *message);
size_t security__address__pack
                     (const Security__Address   *message,
                      uint8_t             *out);
size_t security__address__pack_to_buffer
                     (const Security__Address   *message,
                      ProtobufCBuffer     *buffer);
Security__Address *
       security__address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   security__address__free_unpacked
                     (Security__Address *message,
                      ProtobufCAllocator *allocator);
/* Security__StringMatch methods */
void   security__string_match__init
                     (Security__StringMatch         *message);
size_t security__string_match__get_packed_size
                     (const Security__StringMatch   *message);
size_t security__string_match__pack
                     (const Security__StringMatch   *message,
                      uint8_t             *out);
size_t security__string_match__pack_to_buffer
                     (const Security__StringMatch   *message,
                      ProtobufCBuffer     *buffer);
Security__StringMatch *
       security__string_match__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   security__string_match__free_unpacked
                     (Security__StringMatch *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Security__Authorization_Closure)
                 (const Security__Authorization *message,
                  void *closure_data);
typedef void (*Security__Rule_Closure)
                 (const Security__Rule *message,
                  void *closure_data);
typedef void (*Security__Clause_Closure)
                 (const Security__Clause *message,
                  void *closure_data);
typedef void (*Security__Match_Closure)
                 (const Security__Match *message,
                  void *closure_data);
typedef void (*Security__Address_Closure)
                 (const Security__Address *message,
                  void *closure_data);
typedef void (*Security__StringMatch_Closure)
                 (const Security__StringMatch *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    security__scope__descriptor;
extern const ProtobufCEnumDescriptor    security__action__descriptor;
extern const ProtobufCMessageDescriptor security__authorization__descriptor;
extern const ProtobufCMessageDescriptor security__rule__descriptor;
extern const ProtobufCMessageDescriptor security__clause__descriptor;
extern const ProtobufCMessageDescriptor security__match__descriptor;
extern const ProtobufCMessageDescriptor security__address__descriptor;
extern const ProtobufCMessageDescriptor security__string_match__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_api_2fworkloadapi_2fsecurity_2fauthorization_2eproto__INCLUDED */
